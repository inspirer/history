
                 Генератор синтаксических анализаторов.
              LALR1 (Eugeniy Gryaznov, 2002, inspirer@inbox.ru)

  Часть 1. Общие концепции.

		Лексический анализатор выдает поток терминальных символов - лексем,
		синтаксический анализатор ведет анализ этого потока, проверяет
		его на корректность, и по заданным правилам собирает отдельные
		символы в более широкие понятия - нетерминальные символы, которые
		в свою очередь собираются в другие нетерминальные символы.

		Этот генератор дает возможность по LALR1 грамматике построить 
		анализатор, позволяющий собрать входной поток до основного 
		нетерминала, и при этом выполнить некоторый набор сопутствующих 
		заданных действий.

  Часть 2. Задание грамматики. Файл syntax.

		Анализ файла с грамматикой ведется построчно, строки, начинающиеся
		с '#' и просто пустые игнорируются.

		Все идентефикаторы case-sensitive, для удобства чтения можно
		использовать тире, но оно сразу заменится на подчеркивание.

		Описание грамматики состоит из двух частей. В первой части содержатся
		определения терминальных символов, а также задание управляющих символов 
		(input и end_of_input), во второй части содержатся определения 
		нетерминалов и правил с ними связанных.

  	2.1 # Начало файла syntax

		Все что описано в этом пункте должно находится в начале файла. Любые
		применения описанных здесь дирректив после определения правил
		вывода недопустимы.

		По умолчанию терминалами являются любые символы ASCII, которые можно
		заключать в одинарные кавычки. Это множество можно расширить, добавив
		в него некоторое количество идентефикаторов, которые понимает
		лексический анализатор. Выглядит это так:

		 .symbols "symbol_file"

		Подразумевается, что в symbol_file содержится информация об остальных
		терминальных символах, причем на каждой строчке находится описание 
		максимум одного терминального символа в виде:

		   pp( имя_терминала[=xx], тип_терминала, "строчное_описание_терминала" скобка_или_запятая ...

		Примечание: временно вместо "скобка_или_запятая ..." здесь 
					находится ", 1 ..."

		у этого макроса может быть больше трех параметров, но учитываются только
		первые три. Строки другого вида игнорируются. Естественно таких файлов 
		может быть несколько. Анализатор нумерует терминалы по порядку начиная 
		с числа 256.

		Нужно выделить основной нетерминал до которого будет собираться эта
		грамматика и терминал, являющийся признаком конца потока. По умолчанию
		это input и EOI соответственно.

		Пример:   .input nonterminal
		          .eoi terminal

	2.2 # Остальные диррективы и определения.

		Следующая дирректива задает имя класса анализа:

		   .context context_class_name

		Предполагается, что он находятся в .h файле с названием по имени
		класса, за исключением случаев, когда имя начинается с большой буквы
		'C' - тогда первая буква отбрасывается.
		В определение этого класса нужно добавить следующие определения:

			private:
				// parser
			    static int gg_translate[256];
			    static short gg_ract[],gg_rlen[],gg_rlex[];
			    static char * gg_text[];
			    gg_msymbol gg_m[1024];
			    gg_symbol gg_next;
			    int gg_head;
			    void gg_apply_rule(int rule);
			    void * gg_create_rule_nterm(int type);
			    void gg_push_stack(gg_msymbol& s);
			    void gg_push_stack_null(int lexem);
			    void gg_pop_stack(int count);
			    int  gg_update_state(int state,int lexem);
			    int  gg_next_state(int state,int lexem);
			    void gg_shift();
			    void parse();
				
                LexAnalyzer_class_name lex;
				TokenPlace_class_name info;
				
		Следующими двумя диррективами нужно задать реакции на ошибки:
   
		   .syntax string
		   .eoparse string

		Пример: 

		   .syntax error(next.where,"syntax error");
		   .eoparse error(next.where,"parse error at end-of-file")

		Классы для нетерминалов можно определять прямо здесь же. Строка,
		состоящая только из `{{' является открывающей определение, а
		из `}}' - закрывающей. Все, что находится между этими строками
		точно в таком же виде перенесется в .h файл анализатора,
		например здесь можно подключить какой-нибудь .h файл.

		Пример:
		{{
			#define FOLLOW(num) gg.sym = (void *) num;
		}}

    2.3 # Определение нетерминалов, их типов и правил.

		Определение нетерминала начинается со строчки:
		    имя_нетерм :: его_тип [, on error: [left] терм [[,] [left] терм ...]]

		Как минимум здесь задается его имя и тип. Имя не должно оканчиваться 
		на `sub` или `opt` (см. opt/sub синтаксис). Тип может быть либо "none",
		либо "follow", либо имя класса C++.

		Далее находятся определения правил и сборок для них. Каждое
		правило начинается со строки: 
		    = список_символов [<< символ_сопост_свертке] [>> none]

		После нее следует некоторое количество строк на С++, задающие
		сборку этого правила. Если тип не `none` и `>> none` не задано,
		то перед сборкой создается экземпляр класса, ассоциированный с 
		собираемым символом.
     
		список_символов - это набор терминалов, нетерминалов или ASCII символов
		(заключенных в одинарные кавычки), разделенных пробелами, плюс можно 
		добавить окончание `opt', означающее, что этот символ необязателен 
		или `sub', т.е. символ подстановочный

		символ_сопост_свертке - см. Часть 3.

		Если некоторый символ использован с окончанием `opt`, то создаются
		два правила:
		   SYMBOLopt ::= SYMBOL
		   SYMBOLopt ::=

		Если окончание было sub, то одно правило разбивается на 2^m правил
		(где m - количество символов в правой части с окончанием sub):
		  было  :  =  A Bsub Csub D
		  стало :  =  A D
		           =  A B D
		           =  A C D
		           =  A B C D
		
		Правило сборки - это исходный код на С++. Для обращения к собираемому
		нетерминалу нужно использовать макрос $$, а для обращения к
		тому, из чего собирается - макросы $0,$1,$2 ...
		т.е. если есть правило 'A -> B C D', то $$ ~ A, $0 ~ B, $1 ~ C, $2 ~ D

		$$ и $i - это указатели, т.е. они указывают на данные, ассоциированные
		с символом (типизированные указатели)

		Если правило сборки не задано (его строки - пустые), значит просто
		создается переменная для собираемого нетерминала. Если не задана
		сборка для правила с пустой правой частью, то переменная не создается
		и с нетерминалом ассоциируется NULL. Если в правой части правила
		присутствовал `opt'-иональный символ, то в случае его отсутствия
		его переменная равна NULL.

		Для определения был ли использован sub символ используется следующий
		синтаксис: если строка начинается с `[0]` то она будет в той
		сборке где sub-символ присутствует, а если с `{0}`, то наоборот.
		Вместо 0 здесь должен стоять номер sub-символа в правой части.
		пример:   
		   = ID '=' expressionsub ';'
		       $0->used++;
		       [0] $0->value = $2;
		       {0} $0->value = NULL;

		Наконец описание нетерминала заканчивается строкой состоящей 
		только из `;;'

		 Пример:

		 A :: int
		   = A '*' A
		     *$$ = (*$0) * (*$2);
		   = A '/' A
		     *$$ = (*$0) / (*$2);
		   = Lint
		     *$$ = *$0;
		 ;;

  Часть 3. Ручное разрешение конфликтов.

		Если случился LALR1 конфликт, хотя на самом деле его можно однозначно
		разрешить, то используется следующий механизм:

		  1. Каждому сдвигу и свертке сопоставляем символ (терминальный
		     или нетерминальный):
		        сдвигу - считываемая лексема
		        свертке - последний из терминалов в правой части
		           правила (если в правой части правила нет терминалов, то
		           приоритет неопределен)
		        можно насильно сопоставить свертке символ, указав в конце
		           правила `<< symbol_name`
		           Пример:
		               = ID INT ';' << INT

		  2. Задаем отношения между символами:
       
		       .left symbol_list
		       .right symbol_list
		       .nonassoc symbol_list

		После чего разрешение конфликтов происходит следующим образом:

		если у двух конфликтующих ситуаций приоритеты находятся
		в одном symbol_list-е, то между ними устанавливается отношение
		порядка (левее в списке - приоритетнее), кроме того отношение
		наделяется типом соответствующим symbol_list-у (left/right/nonassoc)

		разрешаем только конфликты, у которых определено отношение порядка:

		1) shift/reduce
		   если тип отношения - left, то сворачиваем
		   если - right, то сдвигаем
		   иначе конфликт не разрешен
		2) reduce/reduce
		   в пользу той свертки, приоритет у которой выше
		   иначе (если приоритеты равны) конфликт не разрешен

		Пример: (классический конфликт сдвиг/свертка)

		   .right Lelse
		   selection-statement :: none
		       = Lif '(' condition ')' statement << Lelse
		       = Lif '(' condition ')' statement Lelse statement
		   ;;

		В файле errors всегда первой выводится ситуация в пользу которой был
		разрешен конфликт.

  Часть 4. Лексический анализатор и класс TokenPlace.

		Класс лексического анализатора должен иметь следующую функцию:

		int gettoken(void **sym,int *where);
			возвращает номер лексемы (>255) или номер символа (<=255), в
			переменную sym записывает указатель на ассоциированные данные
			(или NULL при их отсутствии), в переменную where - индекс
			позиции (см. ниже)

		Класс TokenPlace

			where - индекс позиции. Aнализатор должен уметь сопоставлять
			этому индексу полный адрес начала лексемы
			пример: "file.h(5) from file.cpp(10)"
			для того чтобы не хранить одинаковые индексы, используются следующий
			механизм: с каждым индексом ассоциирован счетчик, при создании
			он равен 1, когда он становится равным нулю, индекс больше не
			нужен. Синтаксический анализатор сам следит за индексами, и
			освобождает их, когда они больше не нужны. Следующие функции
			должны быть реализованы в классе TokenPlace:

				void free_place(int place);         уменьшает счетчик на 1
				void use_place(int place,int num);  увеличивает счетчик на num

			В сборке можно обратиться к номеру места определения символа
			через мнемонические переменные @0,@1,@2 .......
			Местом определения нетерминала по умолчанию считается место 
			определения самого левого из его терминалов. В сборке можно
			изменить это написав например:
				gg.where = @2
