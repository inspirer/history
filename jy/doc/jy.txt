
			JY Linker. Описание, принципы работы.
        --------------------------------------------

  	1. Коммандная строка

		jy.exe [infile1 [infile2 [...]]] [-o outfile]
     
		Если не указано имен входных файлов, то производится
		обработка стандартного входного потока.

        По умолчанию именем выходного файла служит имя первого
        из входных с расширением .exe. Это можно изменять
        с помощью ключа -o.

    2. Задача линкера

		Задача здесь более широкая, чем просто "редактор связей", 
		на линкер еще возлагаются обязанности ассемблера

        1. разобрать входной файл (на языке ассемблера), по нему
          построить объектную модель (в ней уже нет инструкций,
          есть только данные и выражения)

        2. из одной или нескольких объектных моделей собрать
          выходной файл

		объектная модель обычно сохраняется во внешнем файле [пока не реализовано]

    3. Синтаксис входного файла

		Комментарии:
			Однострочный комментарий начинается с //

		Выражения:
			Выражение всегда имеет своим значением 32-битное беззнаковое число. В
            логических операциях 0 означает false, иначе true. Приоритет операций,
            и сами операции точно такие же как в языке C/C++.
			( см. grammar или документацию C/C++ )

            Элементарным элементом выражения может быть:
            	число, символьная постоянная, идентификатор,
                выражение в скобках, $, #, section(идентификатор)

            $   			текущее смещение [пример: "a = $+2" ]
            #   			текущее файловое смещение (позиция в выходном файле)
            идентификатор   значение переменной [см. раздел "Пространства имен"]
			section(id)  	если секция с именем id существует, то ее размер, иначе 0
            		замечание: размер выдается в выражениях 1..31, в остальных случаях
                    значение этого символа полагается равным 1. [ см. раздел "секции" ]

            Чтобы некоторой символической переменной присвоить значение некого
            выражения, нужно написать

               имя_переменной = выражение

            В квадратных скобках перед присваиванием можно указать момент подсчета
            ( от 0 до 31 ). Выражения без этого указания являются глобальными,
            и вычисляются до остальных действий. Выражения времени 0 вычисляются во время
            первого прохода. Остальные по порядку между первым и вторым проходом.

            Значение переменной нельзя изменить. В правой части присваивания
            могут использоваться переменные вычисленные ранее. В глобальных выражениях
            недоступны $, #.

            Примеры:
                expr_glob = 1+3+7*2 << 4
				[0] expr_intime = $
                [31] expr_2 = expr_1              // корректно несмотря на то, что
                [1] expr_1 = section(.code)		  // expr_1 определен ниже по тексту

        Инструкции:
			Одна инструкция ассемблера должна находится на одной строке
        	и заканчиваться либо ';' либо переводом строки.

            Непосредственным операндом может служить выражение. Оно вычисляется во время
            второго прохода компиляции, поэтому в нем могут использоваться
            любые видимые переменные

            При адресации памяти не относящиеся к регистрам слагаемые должны
            быть элементарными выражениями. Т.е

              неправильно   lea edx,[4*eax+4*2]  ;lea ebx,[ebp+-1]
              правильно     lea edx,[4*eax+(4*2)];lea ebx,[ebp+(-1)];lea ebx,[ebp-1]

        	nop;nop              // две инструкции на одной строке
            mov eax,ebx
            xor ecx,123*8
            mov ebx,d:cs:[eax]

            В данной реализации заменены следующие конструкции
            на более короткие и читабельные:
                dword ptr       d:
                word ptr		w:
                byte ptr		b:
				qword ptr		q:

            Всегда необходимо указывать размер ячейки памяти ( если это имеет смысл ).
			Такая условность введена для поиска инструкций в таблице.

			mov ebx,d:[4*eax+1]
            mov ebx,d:4*eax+1      // тоже самое что и предыдущая инструкция
			mov ebx,d:[4*eax][1]   // ------------------""------------------
			lea eax,[eax]
		
            В комманде lea и во многих сопроцессорных инструкциях размер
            ячейки неопределен, поэтому его указывать не нужно.

        Секции:
            Секции предоставляют универсальный механизм манипуляции кодом. Они
            отделяют местоположение кода в исходных файлах от его расположения
            в выходном файле.

            Определение секции:

                section имя_секции { некий_код_который_добавится_к_секции } 

            Вставка секции:

                section имя_секции;
                или
				section имя_секции org выражение;

            Может быть сколько угодно определений секции, и только одна вставка.
            Если определений несколько, то они будут выстроены одно за другим.

            Общий смысл таков: там где написано определение секции - кода не
            появится, зато он появится там где произошла вставка.
            Подстановка секций происходит до выполнения всех остальных действий.

        Условия:
        	if( выражение ){ then_statement }
            или 
            if( выражение ){ then_statement } else { else_statement }

            Условная компиляция введена для выкидывания ненужных участков кода,
            которые можно определить только на стадии линковки. Выражение может
            содержать в себе только переменные, определенные в глобальных
            выражениях.

            Если выкидываемая ветка then_statement или else_statement содержала
            выражения, то они выкинуты не будут. Единственное исключение составляют
            выражения времени 0, они будут выкинуты. Метки конечно будут
            проигнорированы.

            Условия не создают нового пространства имен.

        Пространства имен:
			В некотором простом виде в языке присутствуют пространства имен. Основное
            их назначение - не давать пересекаться одинаковым идентификаторам из
            разных файлов (например полученных от С/C++ компилятора).

			Чтобы ввести новое пространство имен, нужно заключить кусок кода
            в операторные скобки:

            тут_объемлющее_пространство_имен
            {  тут_локальное_пространство_имен }
            тут_объемлющее_пространство_имен

			Соответственно все локальные присваивания и метки будут содержаться в
            новом пространстве имен. Поиск имени ведется начиная с локального
            пространства имен, а далее по всем объемлющим. Соответственно
            возникает понятие Names Hiding, т.е. имя из объемлющего пространства
            может быть скрыто локальным переопределением.

            Имена и метки, начинающиеся с точки или подчеркивания автоматически
            попадают в глобальное пространство имен.

            Особым образом ведет себя перемещенный код. Все имена, находящиеся
            в нем, сохраняются в пространстве имен, где он был определен. Поиск
            имен ведется сначала в пространстве имен его определения, и в случае
            неудачи - в пространстве имен, где он был вставлен.

			Каждый файл при компиляции собирается в отдельном пространстве имен.

        Директивы:
        	align выражение
            	Выравнивание текущего смещения на определенную границу. Достигается
                вставкой некоторого количества нулей.

            org выражение
				Изменение значения текущего смещения. Если смещение было изменено
                внутри вызванной секции, {} или if-блока, то при выходе из него
                оно восстановится ( предыдущее смещение + размер блока ).

            code 16_или_32
            	Определение типа кода. При выходе из определения секции или из {}.
                Предыдущее значение восстанавливается.
            
        Определение данных:
            Данные определяются	с помощью ключевых слов
	        	db, dw, dd, dq, dt
            которые задают тип, и после которых через запятую должны
            быть перечислены данные.

            Соответственно это может быть строка, выражение или определение массива.
            Массив определяется так:

              ключ_слово [выражение_задающее_размер]
              или
			  ключ_слово [выражение_задающее_размер:число_которым_заполнить]

            Размерность элемента массива зависит от ключевого слова.
            Перед ключевым словом можно поставить метку, тогда ей будет
            сопоставлено смещение начала данных.

            Примеры:
				db [1024]
                dw 0x012, 'c', "text\n"
				dd (1+2)*789
                a db 0, [7:8]
