
 // Process manipulation
  exc20_p0:
       cmp ah,0x20 ;  jz  create_process
       jmp exc20_p1

   // 1. Create process (ring1)
   //  In:  ah  = 0x20
   //       LDT = process_ldt
   //       dx  = CS for new process (in LDT)
   //       edi = EIP for new process
   //       ecx = stacksize
   //  Out: CF set on error
   //       ax  = PID
   create_process:

      // check
      check_first_ring()
      if (~c){ ax=err_access_denied;jmp set_cf }

      // Save registers
      push ds;push esi;push ecx;push edi;push edx;push ebx

      // Allocate memory for TSS
      ebx=1;ah=6;int 0x20
      if (~c){
         ax=err_wrong_info
        create_process_error:
         pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
         jmp set_cf
      }

      // Fill it (Create basic values)
      push ax;ds=ax;xor esi,esi
      d:[esi]=esi;esi=+4

      // Get stack for RING0
      #shortdef ring0stacksizex ring0stacksize*4096
      ebx=ring0stacksize;xor eax,eax;al=1;int 0x20
      if (~c){ pop bx;jmp create_process_error}
      mov d:[esi],ring0stacksizex-1;esi=+4
      d:[esi]=eax;mov w:[~esi+2],0;esi=+4

      // Get stack for RING1
      #shortdef ring1stacksizex ring1stacksize*4096
      ebx=ring1stacksize;xor eax,eax;al=2;int 0x20
      if (~c){ pop bx;jmp create_process_error}
      mov d:[esi],ring1stacksizex-1;esi=+4
      d:[esi]=eax;mov w:[~esi+2],0;esi=+4

      // Stack for RING2 (not needed)
      xor eax,eax;d:[esi]=eax;esi=+4
      d:[esi]=eax;esi=+4

      // Save CR3, EIP, EFLAGS
      eax=cr3;d:[esi]=eax;esi=+4
      d:[esi]=edi;esi=+4
      eax=0x3246;d:[esi]=eax;esi=+4

      // Set EAX,ECX,EDX,EBX = 0
      xor eax,eax;d:[esi]=eax;esi=+4;d:[esi]=eax;esi=+4
      d:[esi]=eax;esi=+4;d:[esi]=eax;esi=+4

      // Set ESP & EBP to stack top
      ecx=<<12--;d:[esi]=ecx;esi=+4;d:[esi]=ecx;esi=+4;ecx=++>>12

      // Set ESI & EDI = 0
      xor eax,eax;d:[esi]=eax;esi=+4;d:[esi]=eax;esi=+4

      // Set ES=0
      d:[esi]=eax;esi=+4

      // Set CS
      xor eax,eax;ax=dx;d:[esi]=eax;esi=+4

      // DS = CS = ES
      create_alias_data_desc()
      d:[esi]=eax;esi=+4;d:[esi]=eax;esi=+4;d:[72]=eax

      // FS, GS = 0
      xor eax,eax;d:[esi]=eax;esi=+4;d:[esi]=eax;esi=+4

      // Set LDT
      xor eax,eax;sldt ax;d:[esi]=eax;esi=+4

      // Base of IOmap = 104
      eax=104;shl eax,16;d:[esi]=eax

      // Fill IOmap with nulls (and put at end 0xFFFFFFFF)
      ecx=64;xor eax,eax { esi=+4;d:[esi]=0;loop ?^0 }
      esi=+4;xor eax,eax;eax=--;d:[esi]=eax

      // Fix in GDT TSS type (0x89)
      ax=mem_idt_gdt_data;ds=ax
      xor esi,esi;pop ax;si=ax;esi=+0x805
      b:[esi]=0x89

      // Clear HIGH_EAX
      rol eax,16;shr eax,16

      // Add process to process_list (eax=PID)
      push eax
      ax=mem_kernel_data;ds=ax
      esi=process_list
      ecx=max_process
      inc w:[tasks]
      {
        lodsd
        if (eax!=0){ loop ?^1 }
      } esi=-4;

      // No free process entry => free TSS & Ret with err.
      if (eax!=0){
        pop eax
        dx=ax;ah=8;int 0x20
        pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
        ax=err_too_much_tasks
        jmp set_cf
      }

      // Save in list
      pop eax;ebx=eax;rol ebx,16;bx=default_prior
      d:[esi]=ebx

      // Restore registers
      pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
      iret

  exc20_p1:
       cmp ah,0x21 ;  jz  terminate_process
       cmp ah,0x22 ;  jz  kill_process
       jmp exc20_p2

   // 2. Terminate process (self)
   //  In:  ah  = 0x21
   terminate_process:

      ax=mem_kernel_data;ds=ax
      str ax
      w:kill_task=ax
      jmpf d:[kernel_switch]

   // 3. Kill process
   //  In:  ah  = 0x22
   //       bx  = PID
   //  Out: CF set on error
   kill_process:
      push edx;push ecx;push ebx;push eax;push esi;push ds

      // Remove task from list
      ax=mem_kernel_data;ds=ax;
      esi=process_list;ecx=max_process
      {lodsd;shr eax,16;if (ax==bx){d:[~esi-4]=0} loop ?^0}

      // Free TSS
      ax=mem_idt_gdt_data;ds=ax;esi=ebx+0x805
      if (b:[esi]!=0x89){
         pop ds;pop esi;pop eax;pop ebx;pop ecx;pop edx
         ax=err_wrong_info
         jmp set_cf
      }
      b:[esi]=0x92;push ebx;push ds;ds=bx

      // Free TSS_LDT
      ebx=d:[96];ah=0x4;int 0x20

      // Free TSS
      pop ds;pop edx;ah=0x8;int 0x20

      // tasks--
      ax=mem_kernel_data;ds=ax;dec w:[tasks]

      pop ds;pop esi;pop eax;pop ebx;pop ecx;pop edx
      iret

   // 4. Create child process ????
   //  In:  ah  = 0x23
   //       LDT = process_ldt
   //       ecx = stack_size
   //       edx = EIP
   //  Out: CF set on error
   create_child:

      iret

   exc20_p2:
       cmp ah,0x24 ;  jz  next_process
       cmp ah,0x27 ;  jz  set_data_to_code
       jmp exc20_p3

   // 5. Next process
   //  In:  ah  = 0x24
   next_process:

      push eax;push ds
      ax=mem_kernel_data;ds=ax
      if (w:m_task_en==0){ pop ds;pop eax;iret }

      // search for task
      push esi;push edi;xor esi,esi
      si=w:task_no
      edi=process_list_end
      {
         lodsd
         if(ax!=0){
           w:task_no=si
           w:task_lft=ax
           edi=eax>>16
           w:task_PID=di
           jmp ?v1
         }
         if (edi==esi){ esi=process_list }
         jmp ?^0
      }
      pop edi;pop esi

      // Switch next (if more then one task)
      str ax
      if (w:task_PID!=ax){ jmpf d:[task_no] }
      pop ds;pop eax

      iret

   // 6. Get priority
   //  In:  ah  = 0x25
   //       bx  = PID
   //  Out: CF set on error
   //       ax  = priority
   get_priority:

      iret

   // 7. Set priority
   //  In:  ah  = 0x26
   //       bx  = PID
   //       cx  = priority
   //  Out: CF set on error
   set_priority:

      iret

   // 8. Set data seg as code (ring1)
   //  In:  ah  = 0x27
   //       dx  = DataSeg in LDT
   //  Out: CF set on error
   set_data_to_code:

      // check
      check_first_ring()
      if (~c){ ax=err_access_denied;jmp set_cf }

      // Save registers
      push ds;push esi;push ecx;push edi;push edx;push ebx

      // Set LDT as DATA
      sldt ax;and dx,0xF8
      if (ax==0){
         pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
         ax=err_wrong_info
         jmp set_cf
      }
      cx=mem_idt_gdt_data;ds=cx
      xor esi,esi;si=ax;esi=+0x805
      b:[esi]=0x92;push esi;push ds
      ds=ax;xor esi,esi;si=dx;esi=+5

      // If this is Data for ring3 => set it as code for ring3
      bl=b:[esi]&0xFE;
      if (bl!=0xF2){
         pop ds;pop esi;b:[esi]=0x82
         pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
         ax=err_wrong_info
         jmp set_cf
      }b:[esi]=0xFA;

      // Return to LDT her type
      pop ds;pop esi;b:[esi]=0x82

      // Restore registers
      pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
      iret

   exc20_p3:
       cmp ah,0x28 ;  jz start_task
       jmp exc20_n0

   // 9. Start task (ring1)
   //  In:  ah  = 0x28
   //       ds  = segment_with_data
   //       ecx = stacksize
   //       ebx = memory size
   //  Out: CF set on error
   start_task:

      // check
      check_first_ring()
      if (~c){ ax=err_access_denied;jmp set_cf }

      // Set new stack
      push eax;push edx;push edi
      ax=ss;edx=esp;di=mem_kernel_data;ss=di;esp=dos_func_stack
      push edx;push eax

      // Allocate memory for main task
      ah=3;int 0x20;if (~c){
         pop eax;pop edx;ss=ax;esp=edx;pop edi;pop edx;pop eax
         ax=err_no_free_memory;jmp set_cf
      }
      sldt di;push edi;lldt ax
      push ebx;add ebx,ecx;ax=0;int 0x20;pop ebx;if (~c){
         pop eax;pop eax;pop edx;ss=ax;esp=edx;pop edi;pop edx;pop eax
         ax=err_no_free_memory;jmp set_cf
      } add ecx,ebx

      // Copy data to new segment
      push ecx;ecx=ebx<<12;push es;push edi;push esi;es=ax
      xor edi,edi;xor esi,esi;rep movsb;pop esi;pop edi;ax=es;pop es;pop ecx

      // set data to code, create task
      push edx;dx=ax;ah=0x27;int 0x20;ah=0x20;xor edi,edi;int 0x20;pop edx
      pop ebx;lldt bx

      pop edi;pop edx;ss=di;esp=edx;pop edi;pop edx;esp=+4
      iret

tasks:  dw  0

   // In: dx = code_seg, Out: ax = data_alias
   create_alias_data_desc:
      push ds;push esi;push edi

      // Set LDT as DATA & Get it's size (in "di")
      ax=mem_idt_gdt_data;ds=ax;sldt ax;xor edi,edi
      xor esi,esi;si=ax;esi=+0x805;mov di,w:[~esi-5];di=++
      b:[esi]=0x92;push esi;push ds;edi=<<12

      // Search for free descriptor (ax=LDT; edi=LDT_size)
      ds=ax;xor esi,esi
      {
        // No free descriptor?
        if (esi=>edi){
          pop ds;pop esi;b:[esi]=0x82
          pop edi;pop esi;pop ds
          xor eax,eax;ret
        }
        lodsd;lodsd
        ah=&0x80;cmp ah,0
        jnz ?^0
      } sub esi,8;edi=esi;eax=esi;ax=+7;push eax

      // create alias EDI=new_data (ESI=old_code)
      xor esi,esi;si=dx&0xF8
      lodsd;d:[edi]=eax;lodsd;ah=0xF2;d:[~edi+4]=eax

      pop eax;pop ds;pop esi;b:[esi]=0x82
      pop edi;pop esi;pop ds
      ret
