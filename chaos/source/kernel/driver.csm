 // Int 0x22 handler : kernel functions for drivers

// Driver exit code
#shortdef drv_ld_ok 0
#shortdef drv_ld_error 1
#shortdef drv_ld_irq_abs 2
#shortdef drv_ld_int_abs 3
#shortdef drv_ld_dev_abs 4
#shortdef drv_ld_port_confl 5

int_22:
   clc;push ebp
   mov ebp,esp
   and b:[~ebp+12],0xFE
   pop ebp

   cmp ah,0x0 ; jz set_return_code
   cmp ah,0x1 ; jz allocate_soft_int
   jmp int22_d0

   // 1. Set driver return code
   // In: ah  =  0x0
   //     al  =  ret_code
 set_return_code:
   push ds;push ebx
   bx=mem_kernel_data;ds=bx
   b:[drv_signal]=al
   pop ebx;pop ds
   iret

   // 2. Allocate soft int
   // In: ah  =  0x1
   //     al  =  intnum
   //     CS:EDX = ptr to handler
 allocate_soft_int:
   if (al<0x20||(al=>0x70&&al<=0x7F)){ ax=err_wrong_info;jmp set_cf }

   // not loading => exit
   if(w:cs:m_task_en!=0){ ax=err_access_denied;jmp set_cf }

   // set DS:ESI
   push ebp;mov ebp,esp;push ds;push esi;push eax
   si=mem_idt_gdt_data;ds=si
   xor esi,esi;ah=0;si=ax;shl esi,3
   if (b:[~esi+5]!=0){
     pop esi;pop ds;pop ebp
     ax=err_already_used
     jmp set_cf
   }

   // install handler
   eax=edx<<16;ax=w:[~ebp.8];rol eax,16
   d:[esi]=eax;esi=+4
   xor eax,eax;ah=0xEF
   d:[esi]=eax

   pop eax;pop esi;pop ds;pop ebp
   iret

   // 3. Allocate hard int
   // In: ah  =  0x2
   //     al  =  IRQ (0-15)
   //     CS:EDX = ptr to handler
 allocate_hrdw_irq:

   // not loading => exit
   if(w:cs:m_task_en!=0){ ax=err_access_denied;jmp set_cf }

   push ebp;mov ebp,esp;push eax;push esi;push ds

   // Get real int
   and ax,0xF;xor esi,esi;si=ax;esi=+xtable;al=b:cs:[esi]

   // set DS:ESI
   si=mem_idt_gdt_data;ds=si
   xor esi,esi;si=ax;shl esi,3
   if (b:[~esi+5]!=0){
     pop ds;pop esi;pop eax;pop ebp
     ax=err_already_used
     jmp set_cf
   }

   // install handler
   eax=edx<<16;ax=w:[~ebp.8];rol eax,16
   d:[esi]=eax;esi=+4
   xor eax,eax;ah=0xEE
   d:[esi]=eax

   pop ds;pop esi;pop eax;pop ebp
   iret

 int22_d0:
   cmp ah,0x2 ; jz allocate_hrdw_irq
   cmp ah,0x3 ; jz write_code_seg
   iret

   // 4. Write to code segment
   // In: ah  =  0x3
   //     write EBX as dword at CS:EDI
 write_code_seg:
   push ebp;mov ebp,esp;push eax;push esi;push ds;push ecx

   // Set DS:ESI to CS in GDT
   ax=mem_idt_gdt_data;ds=ax
   ax=w:[~ebp.8];and ax,0xF8
   xor esi,esi;si=ax;esi=+0x805

   // EDI < limit
   // ????

   // write data
   cl=b:[esi];b:[esi]=0x92
   push ds;ds=ax;d:[edi]=ebx;pop ds
   b:[esi]=cl

   pop ecx;pop ds;pop esi;pop eax;pop ebp
   iret

  // Some data
xtable:
   db 0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F // master
   db 0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77 // slave
drv_signal: db 0
drv_head: db [16]

  // Driver defines
#shortdef driver_sign 0x0
#shortdef driver_name 0x6
#shortdef driver_size 0xE

  // LOAD driver function
load_driver:
   push ebx;push ecx;push edx;push esi;push edi;push ds;push es

   // Load driver from .bin file
   push esi;clc;ax=0x100;int 0x21

   // File opened
   _if(~nc){

     bx=ax;edi=drv_head;ax=mem_kernel_data;es=ax
     ah=3;mov cx,16;int 0x21

     ifelse (d:[drv_head.driver_sign]=='CHAO'&&ax==16){

       // if driver isn't too big => load it
       ifelse (w:[drv_head.driver_size]<=max_driver_size&&w:[drv_head.driver_size]>0){

         // Allocate memory for driver
         push ebx;ah=6;xor ebx,ebx;bx=w:drv_head.driver_size;int 0x20;pop ebx

         // Read it in memory
         push eax;xor ecx,ecx;cx=w:drv_head.driver_size;cx=<<12
         es=ax;xor edi,edi;ah=3;int 0x21
         ah=2;int 0x21;ax=mem_kernel_data;es=ax
         pop eax

         // set data to code
         push esi
         bx=mem_idt_gdt_data;ds=bx;esi=eax+0x805
         b:[esi]=0xBA
         pop esi

       } else { stc;ax=0xFE }

     } else { stc;ax=0xFF }

   } pop esi

   // If driver loaded => init it
   _ifelse (~nc){

      // set driver as handler for int80
      push esi;push eax
      cx=mem_idt_gdt_data;ds=cx
      xor ebx,ebx;bx=ax;ebx=<<16
      d:[0x400]=ebx;xor ebx,ebx
      bh=0xEF;d:[0x404]=ebx

      // create task to call int80
      ah=3;int 0x20;lldt ax;ebx=1;ax=0;int 0x20
      push ds;ds=ax;d:[0]=0xCF80CD;pop ds
      dx=ax;ah=0x27;int 0x20
      ah=0x20;xor edi,edi;ecx=1;int 0x20
      xor bx,bx;lldt bx

      // Call task
      push ds;bx=mem_kernel_data;ds=bx
      b:drv_signal=0;w:drv_init_task_PID=ax;pop ds
      #shortdef drv_init_task_PID $+5
      callf 0,0x78CD

      // kill task
      bx=ax;ah=0x22;int 0x20

      // Free int80
      xor eax,eax;d:[0x400]=eax;d:[0x404]=eax
      pop eax;pop esi

      // Error => exit
      ax=mem_kernel_data;ds=ax
      if (b:drv_signal!=0){
        ah=0x31;int 0x21

        esi=driver_FATALe;ah=0x31;int 0x21;
        ah=0x30;al=b:drv_signal+'0';int 0x21
        jmp _write_ln_exit
      }

   } else {

      // 0xFE/0xFF - driver header error ; 0x0-0xFD - file errors
      push cs;pop ds;push eax;ah=0x31;int 0x21;pop eax

      // Show error
      esi=driver_err_un;if (ax==0xFF){ esi=driver_err_FF }
      if (ax==0xFE){esi=driver_err_FE};if (ax==0x02){esi=driver_err_02}
      ah=0x31;int 0x21;ax=0x300D;int 0x21;ax=0x300A;int 0x21

   }

   pop es;pop ds;pop edi;pop esi;pop edx;pop ecx;pop ebx
   ret

  // Tasks defines
#shortdef task_sign 0x0
#shortdef task_name 0x3
#shortdef task_stck 0xC
#shortdef task_size 0xE
#shortdef task_head drv_head

  // Loads task into memory & return PID
  // In  : esi = ptr to file_name
  // Out : ax  = PID
loadtask:
   push ebx;push ecx;push edx;push edi;push esi

   // Open file
   ax=0x100;int 0x21;bx=ax
   if (~c){ ax=1;if (bx==2){ax=4} jmp _load_task_err }

   // Get task header
   ax=mem_kernel_data;es=ax
   edi=task_head;cx=16;ah=3;int 0x21

   // Check task
   if (ax!=16||w:task_head.task_sign!='CE'){ ax=2;jmps _load_task_err }

   // Allocate memory for main task
   push ebx;ah=3;int 0x20
   if (~c){ pop ebx;ax=3;jmps _load_task_err }
   lldt ax;xor ebx,ebx;bx=w:task_head.task_size
   ax=0;int 0x20;pop ebx;if (~c){ ax=3;jmps _load_task_err }

   // Read task
   push eax;es=ax;xor edi,edi;xor ecx,ecx
   ah=3;mov cx,w:task_head.task_size;shl ecx,12;int 0x21
   ah=2;int 0x21;ax=mem_kernel_data;es=ax
   pop eax

   // set data to code, create main task & clear LDTR
   dx=ax;ah=0x27;int 0x20;xor ecx,ecx;ah=0x20
   xor edi,edi;cx=w:cs:task_head.task_stck;int 0x20
   xor bx,bx;lldt bx

   pop esi;pop edi;pop edx;pop ecx;pop ebx
   ret

 // 1 - file not found ; 2 - header ; 3 - memory
_load_task_err:
    pop esi;push eax;ah=0x31;int 0x21;pop eax
    if (ax==1){ esi=driver_err_un } if (ax==2){ esi=task_head_err }
    if (ax==3){ esi=memory_error_ } if (ax==4){ esi=driver_err_02 }
    ah=0x31;int 0x21
_write_ln_exit:
    ax=0x300D;int 0x21;ax=0x300A;int 0x21
    jmp _dos_exit

driver_err_FF: db ": ChaOS driver error",0
task_head_err: db ": ChaOS executable error",0
driver_err_FE: db ": driver is too big",0
driver_err_02: db ": file not found",0
driver_err_un: db ": unknown file error",0
memory_error_: db ": not enough memory to load",0
no_tasks_err_: db "no tasks found in chaos.ini",0
driver_FATALe: db ": FATAL error ",0
chaos_ini    : db "chaos.ini",0


  // Initialize drivers & tasks from "chaos.ini"
init_drivers:

   // Open chaos.ini
   ax=0x100;esi=chaos_ini;int 0x21
   if (~c){
     ah=0x31;int 0x21;esi=driver_err_02;ah=0x31;int 0x21
     jmp _write_ln_exit
   }
   bx=ax

   push es;ax=mem_kernel_data;es=ax;edi=_ini_str_
   {
      push edi;ah=3;cx=120;edi=_ini_data_;int 0x21;pop edi
      if(ax>0){
        xor ecx,ecx;cx=ax;esi=_ini_data_
        {
          lodsb
          ifelse (al==10||al==13){
            xor eax,eax;stosd
            edi=_ini_str_
            if (b:[edi]!=0){
               push esi;esi=edi

               // Prepeare to load ( "," => 0 )
               push esi;al=1;while(al!=0&&al!=','){lodsb}
               dec esi;b:[esi]=0;pop esi

               ifelse (b:[esi]=='*'){

                  // Load driver
                  inc esi;load_driver()

               } else {

                  // Load task DS:ESI
                  loadtask();w:[xtask_PID]=ax

               }
               pop esi
            }

          } else {
            stosb
          }
          loop ?^0
        }
        jmp ?^1
      }
   }
   pop es

   ah=2;int 0x21

   // If no task loaded => exit
   if (w:cs:[tasks]==0){
      ax=mem_kernel_data;ds=ax;esi=no_tasks_err_
      ah=0x31;int 0x21;ax=0x300D;int 0x21;ax=0x300A;int 0x21
      jmp _dos_exit
   }
   ret
