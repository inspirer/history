 // ChaOS kernel Loader
#shortdef debug 1
#output chaos.com
#org 0x100
#code 16
  jmp start
    #include source\kernel\crt.ch
  start:

  printf("\nStarting ChaOS/alpha ...\n")

  !kern:db "kernel.bin",0
  ax=0x3D00;dx=kern;int 0x21;bx=ax     // Open kernel

  if (~c){
    printf("ERROR: kernel file not found\n")
    ret
  }

  ah=0x3F;cx=50000;dx=kernel;int 0x21  // Read kernel
  w:kern_size16=ax

  if (~c||ax<5000){
    printf("ERROR: kernel file damaged\n")
    ret
  }
  ah=0x3E;int 0x21                     // Close

  w:stack=sp
  ax=cs;w:oldseg=ax;w:[kernelloader.dos_call_addr]=ax
  movzx eax,ax;eax=<<4
  d:des_ds+2=|eax;d:des_cs+2=|eax // prepare cs,ds

  bx=mgdt;movzx ebx,bx;ebx=+eax
  d:forgdt+2=|ebx                 // Data to load GDT

  bx=kernelloader;movzx ebx,bx;ebx=+eax
  d:kerloader_cs+2=|ebx           // prepare kerloader_cs
  d:kerloader_ds+2=|ebx           //          kerloader_ds

  cli
  lgdt  [forgdt]                  // Load GDT

  mov   al,0xD1                   // Open A20
  out   0x64,al
  mov   al,0xDF
  out   0x60,al

  mov   eax,cr0
  or    al,1
  mov   cr0,eax                   // Switch PM

  jmpf  $+5,0x8

  ax=0x10;ds=ax;ss=ax

  jmpf  0,0x18

exit:

  mov eax,cr0
  and al,0xfe
  mov cr0,eax                     // Switch to Real
  db  0xea
  dw  $+4
oldseg:
  dw 0                       // real CS

  sp=cs:w:stack
  ax=cs;ds=ax;ss=ax;es=ax
  lidt [foridt]

  // Close A20
  mov   al,0xD1
  out   0x64,al
  mov   al,0xDD
  out   0x60,al

  if (ecx==1){
    printf("Exception \H at \H : \H\n",esi,edi,ebp)
  }

  printf("ChaOS/alpha finished\n")

  sti
  ret

dos_vm_call:

  nop
  int 0x21
  int 0xFF

mgdt:
des_null:
  dd 0,0
des_cs:
  dw 0FFFF,0,0x9A00,0
des_ds:
  dw 0FFFF,0,0x9200,0
kerloader_cs:
  dw 0FFFF,0,0x9A00,0x40
kerloader_ds:
  dw 0FFFF,0,0x9200,0        // Data
kerloader_es:
  dw 255,0,0x9210,0x80       // Memory (at 1Mb, size: 1Mb)

#shortdef gdt_size_16 $-mgdt-1

foridt:
  dw 4*256-1
  dd 0

stack:
  dw 0

#data

kernelloader:
#org 0
#code 32

#shortdef gdt_place  0x800
#shortdef kern_place 0x11000 // After IDT & GDT

   ax=0x20;ds=ax
   ax=0x28;es=ax

   // ds - data ; es - memory for kernel ; !!! stack not defined !!!

   xor edi,edi
   xor eax,eax
   ecx=0x10800
   rep stosb         // Clear

   edi=gdt_place
   esi=gdtstart
   ecx=gdt_size
   rep movsb         // Prepare GDT

   lidt  [foridt32]  // Load IDT

   edi=kern_place
   esi=kernel32
   ecx=d:kern_size32
   rep movsb         // Prepare Kernel
   //xor edx,edx
   //{ lodsb;xor al,b:[decode.edx];stosb;inc edx;
   //   if(edx=>decode_size){xor edx,edx};loop ?^0 }

   esi=ret_to_loader
   ecx=ret_to_loader_size
   rep movsb         // Prepare return code

   lgdt [forgdt32]
   jmpf 0,0x8

   // end
ret_addr:

   jmpf exit,0x8

gdtstart:

#include source\kernel\gdt.csm

#shortdef gdt_size $-gdtstart

//decode:
//  #binary source\kernel\_code_.bin
//#shortdef decode_size $-decode

ret_to_loader:
  jmpf ret_addr,0x18

forgdt16:
  dw gdt_size_16
  dd 0

dos_call_addr:
  dw 0
  dw dos_vm_call
  dw kernel

#shortdef forgdt forgdt16+kernelloader
#shortdef ret_to_loader_size $-ret_to_loader

foridt32:
  dw 2047
  dd 0x100000

forgdt32:
  dw 0xFFFF
  dd 0x100800

kern_size32:
  dd 0
#shortdef kern_size16 kern_size32+kernelloader

// Here we load kernel
#shortdef kernel   kernelloader+$
#shortdef kernel32 $
