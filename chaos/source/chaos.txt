   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    Операционная система ChaOS, руководство программиста

   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   Глава 1. Идеология

     Ядро   операционной   системы   строится  по  следующему  принципу.
   Во-первых  процессы должны быть нормально изолированны друг от друга,
   так  чтобы нестабильная работа одного не смогла бы повлиять на другой
   процесс или на само ядро.


   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   Глава 2. Распределение памяти между процессами

     Память  выделяется  блоками  по  4Kb.  Любой процесс может выделить
   память  в  своей  LDT.  Кроме  этого драйвера, имеющие первый уровень
   привилегированности  могут  выделять  память  в  GDT.  Функции памяти
   находятся   на  0x20  прерывании,  причем  при  вызове  в  ah  должен
   содержаться номер вызываемой функции. Все функции 0x20-ого прерывания
   сохраняют  все  регистры  кроме  изменяемых. Если во время выполнения
   функции произошла какая-нибудь ошибка, то функция поднимает CF и в AX
   возвращает код ошибки. Список ошибок смотри ниже.

       1 Allocate memory

     In:  ah  = 0x00
          al  = 0 (ring3), 1 (ring0), 2 (ring1)
          ebx = Size in pages
     Out: CF(error) or ax=SEG_of_new_block

     Выделяется  кусок  памяти,  в LDT, размером в 4096*ebx байт. Если в
   LDT  нет  свободного  дескриптора  или  нет  достаточного  количества
   памяти,  то  функция  поднимает  CF,  и в AX возращает код ошибки. Из
   третьего уровня привилегированности al будет всегда приравнен нулю.

       2 Free memory

     In:  ah  = 0x01
          dx  = SEG to Free
     Out: CF(error)

     Освобождается  кусок  памяти  в  LDT,  выделенный функцией Allocate
   memory.  Если  в  LDT  нет  указанного  дескриптора  или нет прав его
   освободить, то функция поднимает CF, и в AX возращает код ошибки.

       3 Resize memory

     In:  ah  = 0x02
          ebx = NewSize
          dx  = SEG of block (in LDT)
     Out: CF(error)

     Изменяет   размер   указанного  блока  на  4096*ebx.  Если  NewSize
   превышает  OldSize, то в конец блока добавляются неинициализированные
   4096*(NewSize-OldSize) байт (т.е. не обязательно нули). Если наоборот
   OldSize>NewSize,    то    последние    4096*(OldSize-NewSize)    байт
   освобождаются,  а  первые  4096*NewSize  остаются  неизменными.  Если
   сегмент  отсутствует, NewSize=0, нет свободной памяти, или просто нет
   прав  на  этот  сегмент, то функция устанавливает CF и возвращается с
   ошибкой.

       7 Allocate Global

     In:  ah  = 0x06
          ebx = size in pages (4096)
     Out: CF set on error (not enough memory, free desc. absent)
          ax  = SEG of global

     Выделяет  кусок памяти в GDT. Возможно только для ring1/ring0. Если
   произошла  ошибка,  устанавливается  CF,  если  все  нормально  в  AX
   возвращается селектор выделенной памяти.

       8 Resize Global

     In:  ah  = 0x07
          ebx = NewSize in pages (4096)
          dx  = SEG of global
     Out: CF(error)

     Изменяет  размер  памяти, уже выделенной в GDT. DX должен ссылаться
   на правильный дескриптор, ebx должен быть не равен нулю, а дескриптор
   должен  иметь уровень доступа равным еденице. При изменении размера в
   большую  сторону, память наращивается сверху, в меньшую - обрезается.
   И в том, и в другом случае сохраняются данные.

       9 Free Global

     In:  ah  = 0x08
          dx  = SEG of global
     Out: CF(error)

     Освобождает  память  выделенную  функцией Allocate global. В случае
   ошибки возвращается с установленным CF.

       10 Defragment

     In:  ah  = 0x09
     Out: <none>

     Собирает все куски свободной памяти в один, но большой.

       11 Get free memory info

     In:  ah  = 0x0A
     Out: edx = free memory

     Возвращает  количество  свободной  памяти  в блоках по 4096 байт (в
   страницах).

       12 Map global

     In:  ah  = 0x0B
          ebx = memory_to_MAP address
          dx  = global selector
     Out: CF(impossible)

     На  страничном  уровне  меняет  местами  два куска памяти, размером
   указанном  в  дескрипторе,  на который ссылается <dx>, один по адресу
   ebx,  другой  по адресу из дескриптора. После выполнения функции, оба
   куска  памяти  содержат  одни  и те же данные (которые были по адресу
   ebx),  а  дескриптор  адресуемый  dx-ом теперь ссылается на память по
   физическому    адресу    ebx.   Функция   требует   нулевого   уровня
   привилегированности.

   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   Глава 3. Мультизадачность.

     К  функциям  ядра  относятся  и функции распределения времени между
   процессами.   Управление  мультизадачностью  возможно  через  функции
   0x20-ого прерывания.

