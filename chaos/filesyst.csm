 // File system routines

  exc_21:
    cmp ah,0 ; jz  CreateFile
    cmp ah,1 ; jz  OpenFile
    jmp _fs01

    // 1. Create file
    //   In:  ah  = 0 ; cx  = File attribute
    //        ds:esi - Name (ASCIIZ)
    //   Out: CF set on error (ax = dos error code)
    //        ax  = file handle
  CreateFile:
    iret

    // 2. Open file
    //   In:  ah  = 1
    //        al  = access mode (0-read, 1-write, 2-r/w)
    //        ds:esi - Name (ASCIIZ)
    //   Out: CF set on error (ax = dos error code)
    //        ax  = file handle
  OpenFile:
    push edi;push es;push ebx;push esi

    // prepeare ES:EDI
    xor edi,edi;di=w:cs:dos_vm_call;edi=<<4
    movzx esi,w:cs:dos_vm_call.4;add edi,esi
    si=mem_all_data;es=si

    // Prepeare registers
    push ds;si=mem_kernel_data;ds=si
    ah=0x3D;w:[VM_TSS.tss_eax]=ax
    ax=w:[dos_vm_call.4]
    w:[VM_TSS.tss_edx]=ax
    pop ds;pop esi;push esi

    // Copy filename to dos buffer
    { lodsb;stosb;cmp al,0;jnz ?^0 }

    // Call it
    call_VM_task()

    if (ebx!=0){
      pop esi;pop ebx;pop es;pop edi
      jmp set_cf
    }

    // Restore
    pop esi;pop ebx;pop es;pop edi
    iret

_fs01:
    cmp ah,2 ; jz  CloseFile
    jmp _fs02

    // 3. Close file
    //   In:  ah  = 2 ; bx  = file handle
    //   Out: CF set on error (ax = dos error code|ax=undef)
  CloseFile:
    push ebx;push ds;push es

    // Prepeare registers
    ax=mem_kernel_data;ds=ax;es=ax
    w:[VM_TSS.tss_eax]=0x3E00
    w:[VM_TSS.tss_ebx]=bx
    xor eax,eax

    // Call it
    call_VM_task()

    // Restore
    pop es;pop ds;pop ebx
    iret

    // 4. Read file
    //   In:  ah  = 3
    //        bx  = file handle
    //        cx  = bytes to read
    //        es:edi - buffer
    //   Out: CF set on error (ax = dos error code)
    //        ax  = bytes actually read
  ReadFile:
    push esi;push edi;push ds;push ebx

    // Prepeare registers
    ax=mem_kernel_data;ds=ax
    w:[VM_TSS.tss_eax]=0x3F00
    w:[VM_TSS.tss_ebx]=bx
    w:[VM_TSS.tss_ecx]=cx
    ax=w:[dos_vm_call.4]
    w:[VM_TSS.tss_edx]=ax
    xor eax,eax

    // Call it
    call_VM_task()

    // All OK?
    ifelse (ebx==0){

      // Yes
      push eax;push eax

      // DS:ESI
      xor esi,esi;si=w:cs:dos_vm_call;esi=<<4
      movzx eax,w:cs:dos_vm_call.4;add esi,eax
      ax=mem_all_data;ds=ax

      // Copy received data & save result
      pop ecx;rep movsb

      // Return OK
      pop eax

    } else {

      // No => set CF
      pop ebx;pop ds;pop edi;pop esi
      jmp set_cf
    }

    // Restore
    pop ebx;pop ds;pop edi;pop esi
    iret

  _fs02: // Continue check
    cmp ah,3  ; jz  ReadFile
    cmp ah,4  ; jz  WriteFile
    cmp ah,14 ; jz  GetCurDir
    jmp _fs03

    // 5. Write file
    //   In:  ah  = 4 ;  bx  = file handle
    //        cx  = bytes to write (0-truncate)
    //        ds:esi - buffer
    //   Out: CF set on error (ax = dos error code)
    //        ax  = bytes actually written
  WriteFile:
    iret

    // 15. Get current directory
    //   In:  ah  = 14 ; dl  = drive number
    //        es:edi - place for it
    //   Out: CF set on error (ax = dos error code)
  GetCurDir:
    iret

_fs03:
    cmp ah,187 ; jz display_char
    xor eax,eax
    iret

  // al = char to display
  display_char:

    push ds;push eax
    write_char()
    pop eax;pop ds

    iret
