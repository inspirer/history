
        xasm x86/watcom/build of Sa 18-11-2000

   XASM - это универсальный ассемблер. На нем можно создавать
   абстрактный машинный код, не привязанный к конкретной организации
   памяти. Собственно нужно это для написания скорее системных вещей,
   таких как: загрузочные записи, драйверы, операционные системы,
   резиденты и т.д.

   !!! Help
   'xasm -?' выведет общую подсказку
   'xasm -i' создаст xasm.txt, содержащий список комманд, поддерживаемых
             xasm-ом

   Препроцессор.
   В xasm встроен препроцессор по синтаксису совпадающий с Си-шным,
   т.е работают следующие диррективы
     #include "local_file_name"
     #include <glob_file_name>
     #define <label> <text....><endl>
     #undef <label>
     #ifdef <label>
     #ifndef <label>
     #else
     #endif
     #error <message>
   в #define нельзя определять функции - это пока не доработано
   кроме этого есть ассемблерные диррективы (x это число):
     #code x    // 16 или 32 - в какой код компилировать
                // !! по умолчанию code32
     #align x   // выравнивает смещение на границу, делящуюся на x
     #org x     // задает новое смещение (x - dec)

   Компиляция.
   В два прохода. Перед вторым возможна оптимизация (ключ -o). Тогда
   происходит что-то типа:
     mov reg32,0  -> xor reg32,reg32
     add reg32,0  ->                  // просто удаляется
     shl(r) reg32,1  -> shl(r) reg32  // на байт меньше занимает

   Синтаксис.
   Диррективы должны выделяться в отдельные строчки, а все остальные
   комманды могут разделяться ';','{','}' или концом строки. Все, что
   заключено в /* */ или находится после // - комментарий. фигурные
   скобки используются как операторные, т.е. в месте встречи фигурной
   скобки ставится метка, на которую можно перепрыгнуть, или
   использовать как число (равное ее смещению) используя идентефикатор
   up(xx) и down(xx). up для открывающей, down для закрывающей
   параметр xx - уровень вложенности скобок, т.е. для последних это
   00 для предпоследних 01 и т.д
   пример:
     { lodsb;stosb;cmp al,0;jnz up(00) }  копирование ASCIIZ строки
     { cmp eax,125;jnz down(00); ..... }  организация условий
     {                     // 1           цикл вида
       {                   // 2            while(al==7||al==8){ ... }
         cmp al,7          // 3
         jz  down(00)      // 4  down(00) = 7
         cmp al,8          // 5
         jnz down(01)      // 6  down(01) = 10
       }                   // 7
       ...                 // 8
       jmp up(00)          // 9  up(00)   = 1
     }                     // 10


   !! часть ограниченная треугольными скобками не обязательна,
   !! <т.е может и не присутствовать>

   определение языка:
       комманда
   комманда:
       ассемблерная комманда, определение данных или определение метки
   ассемблерная комманда:
       <prefixes> cmd <operand<,operand<,operand>>>
   идентефикатор:
       слово состоящее из символов: A..Za..z_~
   prefixes:
       любое количество префиксов(предопределенных идентефикаторов)
       через пробел
   cmd:
       комманда процессора
   operand:
       непосредственный операнд (Imm), регистр(Reg) или память(Mem)
   Imm:
       любое константное выражение, состоящее из скобок, чисел,
       идентификаторов и операций над ними
   число:
       0x<HEX>
       Q<HEX>h       // Q принадлежит мн-ву 0..9
       0<OCT>
       <DEC>
       'aaaa'        // это тоже число (0x61616161)
       'a'           // и это число
   операции:
       +-*/%   арифметические
       ^&|     побитовые
       >>      сдвиг направо
       <<      сдвиг налево
       **      возведение в степень
       приоритет: скобки, потом все кроме '+-' (выполняются по порядку),
       потом '+-'. пример: (5*81-458>>1)**2
   Reg:
       предопределенный идентефикатор, ассоциируемый с
       процессорным регистром
   Mem:
       <memprefix>[memexpression]
   memprefix:
       любое количество переопределений сегментных регистров и размерности
       операнда отделенных друг от друга и от [memexpression] двоеточием.
                   XASM        TASM/MASM
         mem8  =  b:[...]      byte ptr [...]
         mem16 =  w:[...]      word ptr [...]
         mem32 =  d:[...]      dword ptr [...]
         mem64 =  q:[...]      qword ptr [...]
         mem   =  [...]        [...]
       в отличии от TASM/MASM/etc размерность операнда важна. (см. список
       opcode-ов). Если требуется переопределить сегмент, то используйте
       конструкцию:  cs:[...], ds:[...], etc.
       пример: w:cs:[...], fs:q:[...], cs:[...]
   memexpression:
       стандартное выражение для обращения к памяти. При использовании
       структуры вида [число]*[регистр] первым должно идти число (1248),
       потом умнож.(*), потом регистр.
       пример: [4*eax+ebx] [(4+5)**2+eax+ebx] [bp+sp] [ax+81]
       если используется смещение и оно не велико <128, то можно
       поставить сразу после '[' знак '~', тем самым сэкономив
       три байта.
   определение данных:
       тип данные<,данные<,данные<,....>>>
       пример: db "aaa\n",0
               dw 2**14+582
               db 'a',0
   тип:
       db - байт           char
       dw - слово          int
       dd - двойное слово  long
   данные:
       строка, число(Imm) или массив
   строка:
       любые символы в двойных кавычках
       \n заменяется на 13,10
       \t на 9
       \<sym> на <sym>
   массив:
       [число(Imm)]  // массив из нулей, размером указанным в []
   определение метки:
       'идентификатор:' причем идентификатор должен быть уникальным



   ПРИМЕР:

   // sample.sm
   // system: DOS,  type: COM
   // xasm sample.sm sample.com
   #org 256
   #code 16

       mov ah,9
       mov dx,str
       int 0x21
       ret

   str:  db "Hello\n$",0
