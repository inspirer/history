 // Memory functions

 // Descriptor definitions
#shortdef mem_kernel_code 0x8
#shortdef mem_idt_gdt_data 0x10
#shortdef mem_page_catalog 0x18
#shortdef mem_kernel_data 0x20
#shortdef mem_all_data 0x28
#shortdef mem_start_desc 0x30

 // Page definitions
#shortdef busy_page  512
#shortdef fixed_page 1024

 // ErrorCodes
#shortdef err_no_free_desc 1
#shortdef err_no_free_memory 2
#shortdef err_no_support 3
#shortdef err_no_free_LDT_desc 4
#shortdef err_wrong_info 5
#shortdef err_access_denied 6
#shortdef err_too_much_tasks 7

   exc_20:

      // Clear CF
      clc;push ebp
      mov ebp,esp
      and b:[~ebp+12],0xFE
      pop ebp
      cmp ah,0
      jz allocate_memory
      jmp exc20_r0

   //   1. Allocate memory
   //     In:  ah  = 0x0
   //          al  = 0 (ring3), 1 (ring0), 2 (ring1)
   //          ebx = Size in pages
   //     Out: CF set on error (not enough memory, free desc. absent)
   //          ax  = SEG of block
   allocate_memory:

      // Allocate Zero memory => error
      if (ebx==0){
         ax=err_wrong_info
         jmp set_cf
      }

      // Save registers & get priority for segment
      push ds;push esi;push ecx;push edi;push edx;push ebx;push ebp
      bp=ax&0xF

      // Set LDT as DATA & Get it's size (in "di")
      sldt ax
      if (ax==0){
         pop ebp;pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
         ax=err_wrong_info
         jmp set_cf
      }
      cx=mem_idt_gdt_data;ds=cx;xor edi,edi
      xor esi,esi;si=ax;esi=+0x805;mov di,w:[~esi-5];di=++
      b:[esi]=0x92;push esi;push ds;edi=<<12

      // Search for free descriptor (ax=LDT; edi=LDT_size)
      ds=ax;xor esi,esi
      {
        // No free descriptor?
        if (esi=>edi){
          ax=err_no_free_desc;pop ds;pop esi;b:[esi]=0x82
          pop ebp;pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
          jmp set_cf
        }
        lodsd;lodsd
        ah=&0x80;cmp ah,0
        jnz ?^0
      } edx=esi-8

      // Search for free memory (desc found in "edx")
      push ds;xor ecx,ecx
      ax=mem_page_catalog;ds=ax
      esi=cs:d:mem_base<<2+4096 // <- base memory pointer
      edi=cs:d:mem_size<<2+4096 // <- pointer to end of memory
      while(esi<edi&&ecx!=ebx){
         lodsd
         ax=&busy_page
         ifelse (ax==0){
           ecx=++
         } else {
           ecx=0
         }
      }

      // No free memory => error
      if (ecx!=ebx){
        ax=err_no_free_memory;esp=+4;pop ds;pop esi;b:[esi]=0x82
        pop ebp;pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
        jmp set_cf
      }
      ecx=<<2;esi=-ecx

      // Found free memory at "esi" and free descriptor in "edx"

      // Reserve it
      push esi;ecx=>>2
      {
        lodsd
        ax=|busy_page
        mov d:ds:[~esi-4],eax
        loop ?^0
      }

      // Prepeare values
      pop esi;pop ds
      esi=-4096;esi=<<10
      edi=edx;ebx=--;eax=edx+4

      // Create descriptor (at <ds:edi> to mem at <esi>)
      edx=esi<<16;dx=bx      // first dword (low_size,low_limit)
      d:[edi]=edx
      ebx=>>16&15;esi=>>16   // (hi/med_place & hi_limit)
      edx=esi;dl=0xC0+bl     // (hi_size+attr(32-bit,pages)+hi_limit
      edx=<<16;dx=si;dh=0x92 // (med_dize+attr(present, for 1/0 users,r/w))
      ifelse (bp==2){ dh=0xB2;eax=++ } else { if (bp==0){dh=0xF2;eax=+3}}
      d:[~edi+4]=edx

      // reread page's catalog
      ebx=cr3;cr3=ebx

      // Return to LDT her type
      pop ds;pop esi;b:[esi]=0x82

      // Restore registers
      pop ebp;pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
      iret

exc20_n0:
      cmp ah,1 ; jz free_memory
      jmp exc20_n1

   //   2. Free memory
   //     In:  ah  = 0x1
   //          dx  = SEG to Free
   free_memory:

      // Save registers
      push ds;push esi;push ecx;push edi;push edx;push ebx

      // Set LDT as DATA
      sldt ax;and dx,0xF8
      if (ax==0){
         pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
         ax=err_wrong_info
         jmp set_cf
      }
      cx=mem_idt_gdt_data;ds=cx
      xor esi,esi;si=ax;esi=+0x805
      b:[esi]=0x92;push esi;push ds
      ds=ax;xor esi,esi;si=dx

      // If it's not memory/ring3 with data => error
      mov al,b:[~esi+5];and al,0xFE
      if (al!=0xF2){
         pop ds;pop esi;b:[esi]=0x82
         pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
         ax=err_wrong_info
         jmp set_cf
      }push esi

      // Save location & limit
      lodsw;cx=ax;ecx=<<16
      lodsw;dx=ax;edx=<<16
      lodsb;dl=al
      lodsb;lodsb;cl=al&15
      lodsb;dh=al
      ecx=<16+1;edx=<16>>10 + 4096

      // Free descriptor
      pop esi;xor eax,eax
      d:[esi]=eax;d:[~esi+4]=eax

      // Free pages (ecx = num_of_pages ; edx = location in table)
      ax=mem_page_catalog;ds=ax;esi=edx
      {
        lodsd;and ax,0xFFFF-busy_page
        mov d:ds:[~esi-4],eax
        loop ?^0
      }

      // reread page's catalog
      ebx=cr3;cr3=ebx

      // Return to LDT her type
      pop ds;pop esi;b:[esi]=0x82

      // Restore registers
      pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
      iret

   //   3. Resize memory
   //     In:  ah  = 0x2
   //          ebx = NewSize
   //          dx  = SEG of block
   //     Out: CF set on error (not enough memory)
   resize_memory:

      // ????

      ax=err_no_support
      jmp set_cf
      iret

   //   4. Allocate LDT
   //     In:  ah  = 0x3
   //     Out: CF set on error (free desc. absent)
   //          ax  = LDTNum
   allocate_ldt:

      // Save registers
      push ds;push esi;push ecx;push edi;push edx;push ebx;push ebp

      // Allocate global memory For LDT
      ah=6;ebx=1;int 0x20;xor edx,edx;dx=ax

      // Check if all ok
      if (~c){
        pop ebp;pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
        jmp set_cf
      }

      // Clear table
      ds=dx;ecx=1024;xor esi,esi
      { d:[esi]=0;esi=+4;loop ?^0 }

      // Set LDT
      bx=mem_idt_gdt_data;ds=bx;esi=0x800+edx
      lodsd;lodsb;b:[esi]=0x82;

      // Return LDT
      eax=edx

      // Restore registers
      pop ebp;pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
      iret

exc20_n1:
      cmp ah,2 ; jz resize_memory
      cmp ah,3 ; jz allocate_ldt
      cmp ah,4 ; jz free_ldt
      jmp exc20_n2

   //   5. Free LDT
   //     In:  ah  = 0x4
   //          bx  = LDTNum
   //     Out: CF set on error
   free_ldt:

      // Save registers
      push ds;push esi;push ecx;push edx;push ebx;push eax

      // Set LDT as data
      xor esi,esi;si=bx&0xF8;esi=+0x800
      ax=mem_idt_gdt_data;ds=ax
      lodsd;lodsd;

      // Error (no LDT found there)
      if (ah!=0x82){
         pop eax;pop ebx;pop edx;pop ecx;pop esi;pop ds
         ax=err_wrong_info
         jmp set_cf
      }

      // Else set LDT as Data & get it's size
      ah=0x92;d:[~esi-4]=eax
      xor ecx,ecx;mov cx,w:[~esi-8];ecx=++
      ecx=<<9

      // Get LDTData descr
      push bx;push ds
      ds=bx;xor esi,esi

      // Free each entry in LDT
      {
        // Save location & limit
        push ecx
        lodsw;cx=ax;ecx=<<16
        lodsw;dx=ax;edx=<<16
        lodsb;dl=al
        lodsb

        ifelse (al==0){
          lodsw
        } else {

          lodsb;cl=al&15
          lodsb;dh=al
          ecx=<16+1;edx=<16>>10 + 4096

          // Free descriptor
          xor eax,eax;d:[~esi-8]=eax;d:[~esi-4]=eax

          // Free pages (ecx = num_of_pages ; edx = location in table)
          ax=mem_page_catalog;ds=ax;esi=edx
          {
            lodsd;and ax,0xFFFF-busy_page
            mov d:ds:[~esi-4],eax
            loop ?^0
          }
        }
        pop ecx
        loop ?^0
      }

      // Free LDT & read page's catalog
      pop ds;pop dx;ah=8;int 0x20

      // Restore registers
      pop eax;pop ebx;pop edx;pop ecx;pop esi;pop ds
      iret

   //   6. Load LDT
   //     In:  ah  = 0x5
   //          bx  = LDTNum
   load_ldt:

      // Check is it LDT
      // ????

      // Check if program has rights to do this
      // ????

      lldt bx
      iret

exc20_n2:
      cmp ah,5 ; jz load_ldt
      cmp ah,6 ; jz mem_alloc_global
      jmp exc20_n3

   // 7. Allocate Global
   //   In:  ah  = 0x6
   //        ebx = size in pages (4096)
   //   Out: CF set on error (not enough memory, free desc. absent)
   //        ax  = SEG of global
   mem_alloc_global:

      // if size=0 => error
      if (ebx==0){
        ax=err_wrong_info
        jmp set_cf
      }

      // Save registers
      push ds;push esi;push ecx;push edi;push edx;push ebx

      // Search for free descriptor
      ax=mem_idt_gdt_data;ds=ax
      mov esi,mem_start_desc+0x800
      {
        // No free descriptor
        if (esi=>0x10800){
          ax=err_no_free_desc
          pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
          jmp set_cf
        }
        lodsd;lodsd
        ah=&0x80;cmp ah,0
        jnz ?^0
      } edx=esi-8

      // Search for free memory (desc in "edx")
      push ds;xor ecx,ecx
      ax=mem_page_catalog;ds=ax
      esi=cs:d:mem_base<<2+4096 // <- base memory pointer
      edi=cs:d:mem_size<<2+4096 // <- pointer to end of memory
      while(esi<edi&&ecx!=ebx){
         lodsd
         ax=&busy_page
         ifelse (ax==0){
           ecx=++
         } else {
           ecx=0
         }
      }

      // No free memory => error
      if(ecx!=ebx){
         pop ds;pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
         ax=err_no_free_memory
         jmp set_cf
      }
      ecx=<<2;esi=-ecx

      // Found free memory at "esi" and free descriptor in "edx"

      // Reserve it
      push esi;ecx=>>2
      {
        lodsd
        ax=|busy_page
        mov d:ds:[~esi-4],eax
        loop ?^0
      }

      // reread page's catalog
      esi=cr3;cr3=esi
      pop esi;pop ds

      // Create descriptor
      esi=-4096;esi=<<10
      edi=edx;eax=edx-0x800;ebx=--
      edx=esi<<16;dx=bx      // Prepare first dword (low_size,low_limit)
      d:[edi]=edx
      ebx=>>16&15;esi=>>16   // (hi_med_size & hi_limit)
      edx=esi;dl=0xC0+bl     // (hi_size+attr(32-bit,pages)+hi_limit
      edx=<<16;dx=si;dh=0xB2 // (med_dize+attr(present, for 1/0 users,r/w))
      d:[~edi+4]=edx

      // Restore registers
      pop ebx;pop edx;pop edi;pop ecx;pop esi;pop ds
      iret

exc20_n3:
      cmp ah,7;jz mem_resize_global
      jmp exc20_n4

   // 8. Resize Global
   //   In:  ah  = 0x7
   //        ebx = NewSize in pages (4096)
   //        dx  = SEG of global
   //   Out: CF set on error (not enough memory)

   mem_resize_global:

      push ds;push esi;push edi;push eax;push ecx;push edx

      // memory location
      ax=mem_idt_gdt_data;ds=ax
      xor esi,esi;si=dx;esi=+0x800
      xor ecx,ecx;ebx=--

      // If it's not global => error
      mov al,b:[~esi+5];and al,0x9E
      if (al!=0x92){
         pop edx;pop ecx;pop eax;pop edi;pop esi;pop ds
         ax=err_wrong_info
         jmp set_cf
      }

      // Get it size=ecx and pos=edx
      lodsd;edx=eax;cx=ax;ecx=<16
      lodsb;dl=al;lodsb;lodsb;cl=al&0xF;
      lodsb;dh=al;edx=<16;ecx=<16;esi=-8

      // if new size less then old
      ifelse (ecx=>ebx){

          // Save new size in descriptor
          w:[esi]=bx;ebx=>16;
          lodsd;lodsw;lodsb;al=&0xF0|bl;ebx=>16

          // Free other pages (ebx-new ; ecx-old)
          ecx=-ebx;edx=(>>12+ebx)++
          ax=mem_page_catalog;ds=ax
          esi=edx<<2+4096
          {
            lodsd;and ax,0xFFFF-busy_page
            mov d:ds:[~esi-4],eax
            loop ?^0
          }

          // read page's catalog
          eax=cr3;cr3=eax

      // if new size greater oldsize=ecx, pos=edx & newsize=ebx
      } else {

          // Allocate memory
          ebx=++;ah=6;int 0x20;

          // Error? Yes
          if (~c){
            pop edx;pop ecx;esp=+4;pop edi;pop esi;pop ds
            jmp set_cf
          }

          // No => save desc
          push ax;xor edi,edi;di=ax;edi=+0x800

          // xchg newdesc & olddesc
          eax=d:[esi];ebx=d:[edi];d:[esi]=ebx;d:[edi]=eax
          mov eax,d:[~esi+4];mov ebx,d:[~edi+4]
          mov d:[~esi+4],ebx;mov d:[~edi+4],eax

          // oldpos=edx newpos=?(ebx) ecx=oldsize
          lodsd;ebx=eax;lodsb;bl=al;lodsw;lodsb;bh=al;ebx=<16;esi=-8

          // oldstartpage=esi newstartpage=edi ecx=numofpages
          esi=edx>>10+4096
          edi=ebx>>10+4096
          ecx=++

          // Xchg new & old pages
          ax=mem_page_catalog;ds=ax
          {
             eax=d:[esi];ebx=d:[edi]
             d:[edi]=eax;d:[esi]=ebx
             edi=+4;esi=+4
             loop ?^0
          }

          // Free temporary pages & read page's catalog
          pop dx;ah=8;int 0x20

      }

      // Restore registers
      pop edx;pop ecx;pop eax;pop edi;pop esi;pop ds
      iret

exc20_n4:
      cmp ah,8;jz mem_free_global
      jmp exc20_n5

   // 9. Free Global
   //   In:  ah  = 0x8
   //        dx  = SEG of global
   //   Out: CF set on error

   mem_free_global:

      push ds;push esi;push ecx;push edx;push eax

      // memory location
      ax=mem_idt_gdt_data;ds=ax
      xor esi,esi;si=dx&0xF8
      esi=+0x800
      push esi

      // If it's not global => error
      mov al,b:[~esi+5];and al,0x9E
      if (al!=0x92){
         esp=+4;pop eax;pop edx;pop ecx;pop esi;pop ds
         ax=err_wrong_info
         jmp set_cf
      }

      // Save location & limit
      lodsw;cx=ax;ecx=<<16
      lodsw;dx=ax;edx=<<16
      lodsb;dl=al
      lodsb;lodsb;cl=al&15
      lodsb;dh=al
      ecx=<16+1;edx=<16>>10 + 4096

      // Free descriptor
      pop esi;xor eax,eax
      d:[esi]=eax;d:[~esi+4]=eax

      // Free pages (ecx = limit ; edx = location in table)
      ax=mem_page_catalog;ds=ax;esi=edx
      {
        lodsd;and ax,0xFFFF-busy_page
        mov d:ds:[~esi-4],eax
        loop ?^0
      }

      // reread page's catalog
      eax=cr3;cr3=eax

      // Restore registers
      pop eax;pop edx;pop ecx;pop esi;pop ds
      iret

exc20_n5:
      cmp ah,9;jz mem_defrag_global
      jmp exc20_n6

   // 10. Defragment Global
   //   In:  ah  = 0x9
   mem_defrag_global:

      // ????

      iret

   exc20_n6:
      cmp ah,0xA;jz mem_get_free_info
      ax=err_no_support
   set_cf:
      push ebp
      mov ebp,esp
      or d:[~ebp+12],1
      pop ebp
      iret

   // 11. Get free info
   //   In:  ah  = 0xA
   //   Out: edx = free memory
   mem_get_free_info:

      push ds;push esi;push edi;push eax

      ax=mem_page_catalog;ds=ax

      esi=cs:d:mem_base<<2+4096 // <- base memory pointer
      edi=cs:d:mem_size<<2+4096 // <- pointer to end of memory
      xor edx,edx               // <- pointer to Free part

      while(esi<edi){
         lodsd
         ax=&busy_page
         if (ax==0){ edx=++ }
      }

      pop eax;pop edi;pop esi;pop ds

      iret

   mem_base:
     dd 0     // Memory base pointer (in pages)
   mem_size:
     dd 512   // Minimal size for work = 2Mb (in pages)
