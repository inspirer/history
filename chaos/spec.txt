   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    Операционная система ChaOS, руководство программиста


   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   Глава 1. Распределение памяти между процессами

     Память выделяется блоками по 4Kb. Любой процесс может выделить память
    в своей LDT. Кроме этого драйвера, имеющие первый уровень привилегиро-
    ванности могут выделять память в GDT. Функции памяти находятся на 0x20
    прерывании, причем при вызове в ah должен содержаться номер вызываемой
    функции. Все функции 0x20-ого прерывания  сохраняют все регистры кроме
    изменяемых.   Если во время выполнения  функции произошла какая-нибудь
    ошибка,  то функция поднимает CF и в AX возвращает код ошибки.  Список
    ошибок смотри ниже.

       1 Allocate memory

     In:  ah  = 0x00
          al  = 0 (ring3), 1 (ring0), 2 (ring1)
          ebx = Size in pages
     Out: CF(error) or ax=SEG_of_new_block

       Выделяется кусок памяти, в LDT, размером в 4096*ebx байт. Если в LDT
     нет свободного дескриптора или нет достаточного количества памяти,  то
     функция поднимает CF, и в AX возращает код ошибки. Из третьего уровня
     привилегированности al будет всегда приравнен нулю.

       2 Free memory

     In:  ah  = 0x01
          dx  = SEG to Free
     Out: CF(error)

       Освобождается кусок памяти в LDT, выделенный функцией Allocate
     memory. Если в LDT нет  указанного дескриптора  или нет прав его
     освободить, то функция поднимает CF, и в AX возращает код ошибки.

       3 Resize memory

     In:  ah  = 0x02
          ebx = NewSize
          dx  = SEG of block (in LDT)
     Out: CF(error)

       Изменяет размер указанного  блока на 4096*ebx. Если NewSize превы-
     шает  OldSize,  то в конец  блока  добавляются  неинициализированные
     4096*(NewSize-OldSize)  байт (т.е. не обязательно нули). Если наобо-
     рот OldSize>NewSize, то последние  4096*(OldSize-NewSize) байт осво-
     бождаются, а первые 4096*NewSize остаются  неизменными. Если сегмент
     отсутствует, NewSize=0, нет свободной памяти, или просто нет прав на
     этот сегмент, то функция устанавливает CF и возвращается с ошибкой.

       4 Allocate LDT

     In:  ah  = 0x03
     Out: CF(error) or ax=LDTNum

       Выделяет локальную таблицу дескрипторов. Для вызова этой функции
     нужно находится на первом (ring1) или нулевом (ring0) уровне приви-
     легированности. Возращает в AX селектор LDT в GDT, если функция
     была выполнена успешно. Если нет свободного селектора, или памяти,
     то функция устанавливает CF и возвращается с ошибкой.

       5 Free LDT

     In:  ah  = 0x04
          bx  = LDTNum
     Out: CF(error)

       Освобождает локальную таблицу дескрипторов, и все дескрипторы в ней.
     Для вызова этой функции нужно находится на первом (ring1) или нулевом
     (ring0) уровне привилегированности. Если LDTnum ссылается на неправиль-
     ный дескриптор в GDT, или является текущей LDT, то функция возращается
     с ошибкой.

       6 Load LDT

     In:  ah  = 0x05
          bx  = LDTNum
     Out: CF(error)

       Загружает в LDTR новую таблицу дескрипторов. Для вызова этой функции
     нужно находится на первом (ring1) или нулевом (ring0) уровне привилеги-
     рованности. Если текущий CS ссылается на эту таблицу, или LDTNum от-
     сутствует, то функция возвращается с ошибкой.

       7 Allocate Global

     In:  ah  = 0x06
          ebx = size in pages (4096)
     Out: CF set on error (not enough memory, free desc. absent)
          ax  = SEG of global

       Выделяет кусок памяти в GDT. Возможно только для ring1/ring0. Если
     произошла ошибка, устанавливается CF, если все нормально в AX возвра-
     щается селектор выделенной памяти.

       8 Resize Global

     In:  ah  = 0x07
          ebx = NewSize in pages (4096)
          dx  = SEG of global
     Out: CF(error)

       Изменяет размер памяти, уже выделенной в GDT. DX должен ссылаться
     на правильный дескриптор, ebx должен быть не равен нулю, а дескриптор
     должен иметь уровень доступа равным еденице. При изменении размера в
     большую сторону, память наращивается сверху, в меньшую - обрезается.
     И в том, и в другом случае сохраняются данные.

       9 Free Global

     In:  ah  = 0x08
          dx  = SEG of global
     Out: CF(error)

       Освобождает память выделенную функцией Allocate global. В случае
     ошибки возвращается с установленным CF.

       10 Defragment

     In:  ah  = 0x09
     Out: <none>

       Собирает все куски свободной памяти в один, но большой.

       11 Get free memory info

     In:  ah  = 0x0A
     Out: edx = free memory

       Возвращает количество свободной памяти в блоках по 4096 байт (в
     страницах).

       12 Map global

     In:  ah  = 0x0B
          ebx = memory_to_MAP address
          dx  = global selector
     Out: CF(impossible)

       На страничном уровне меняет местами два куска памяти, размером
     указанном в дескрипторе, на который ссылается <dx>, один по адресу
     ebx, другой по адресу из дескриптора. После выполнения функции, оба
     куска памяти содержат одни и те же данные (которые были по адресу
     ebx), а дескриптор адресуемый dx-ом теперь ссылается на память по
     физическому адресу ebx. Функция требует нулевого уровня привилеги-
     рованности.

   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --






  ──────────────────────────────────────────────────────────────────1─[+++]─
   Create process  │ In:  ah  = 0x20
  ─────────────────┘      LDT = process_ldt
                          dx  = CS for new process (in LDT)
                          edi = EIP for new process
                          ecx = stacksize

   Out: CF_set (error) or  ax = PID
  ──────────────────────────────────────────────────────────────────3─[+++]─
   Kill process    │ In:  ah  = 0x22
  ─────────────────┘      bx  = PID

   Out: CF set on error
  ──────────────────────────────────────────────────────────────────3─[+++]─
   Next process    │ In:  ah  = 0x24
  ─────────────────┘

    Out: <none>
  ──────────────────────────────────────────────────────────────────1─[+++]─
   data -> code    │ In:  ah  = 0x27
  ─────────────────┘      dx  = DataSeg in LDT

    Out: CF set on error
  ────────────────────────────────────────────────────────────────────[---]─
                   │
  ─────────────────┘

  ┌─════════════════════════════════════════════════════════════════─┐
  │  Int 0x22 functions:    Drivers interface                        │
  └┐                                                                 └┐
   └──────────────────────────────────────────────────────────────────┘

  ────────────────────────────────────────────────────────────────────[++-]─
   Drv Return Code │ In: ah  =  0x0
  ─────────────────┘     al  =  ret_code

    Out: CF set on error
  ────────────────────────────────────────────────────────────────────[++-]─
   Alloc Soft Int  │ In: ah  =  0x1
  ─────────────────┘     al  =  intnum
                         CS:EDX = ptr to handler

    Out: CF set on error
  ────────────────────────────────────────────────────────────────────[++-]─
   Alloc Hard Int  │ In: ah  =  0x2
  ─────────────────┘     al  =  IRQ (0-15)
                         CS:EDX = ptr to handler

    Out: CF set on error
  ────────────────────────────────────────────────────────────────────[+--]─
   Write CodeSeg   │ In: ah  =  0x3
  ─────────────────┘     write EBX as dword at CS:EDI

    Out: CF set on error
  ────────────────────────────────────────────────────────────────────[---]─
                   │
  ─────────────────┘
